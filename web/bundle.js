(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
const DEFAULT_ACTIVATION_FUNCTION = sigmoid;
class Neuron {
    constructor(numWeights) {
        this.output = NaN;
        this.weights = [];
        for (let i = 0; i < numWeights; i++)
            this.weights.push(Math.random());
    }
}
exports.Neuron = Neuron;
class NeuralNetwork {
    constructor(numInputs, numHidden, numOutputs) {
        this.numInputs = numInputs;
        this.numHidden = numHidden;
        this.numOutputs = numOutputs;
        // Initialize default params
        this.activationFunc = DEFAULT_ACTIVATION_FUNCTION;
        this.epsilon = 0.5;
        this.acceptableError = 0.001;
        this.maxLearnIterations = 1000;
        // Initialize layers
        this.hiddenLayer = [];
        for (let i = 0; i < numHidden; i++)
            this.hiddenLayer.push(new Neuron(this.numInputs + 1));
        this.outputLayer = [];
        for (let i = 0; i < numOutputs; i++)
            this.outputLayer.push(new Neuron(this.numHidden + 1));
    }
    // -------------------- Forward propagation --------------------
    forwardNeuron(neuron, inputs) {
        if (inputs.length != neuron.weights.length)
            throw new Error(`Invalid size of input array: expecting ${neuron.weights.length}, got ${inputs.length}`);
        let weightedSum = inputs.reduce((accum, input, i) => accum + input * neuron.weights[i], 0);
        neuron.output = this.activationFunc(weightedSum);
        return neuron.output;
    }
    forward(inputs) {
        let hlValues = [];
        let outValues = [];
        this.hiddenLayer.forEach(neuron => hlValues.push(this.forwardNeuron(neuron, this.addBias(inputs))));
        hlValues.push(1); // Add bias
        this.outputLayer.forEach(neuron => outValues.push(this.forwardNeuron(neuron, hlValues)));
        return outValues;
    }
    // -------------------- Back propagation --------------------
    backPropagate(inputs, targets) {
        // Adjust weights for output layer
        let hiddenOuts = this.hiddenLayer.map(neuron => neuron.output);
        let hiddenErrors = [];
        for (let i = 0; i < this.hiddenLayer.length; i++)
            hiddenErrors.push(0);
        for (let i = 0; i < this.outputLayer.length; i++)
            this.backPropagateOutNeuron(this.outputLayer[i], targets[i], this.addBias(hiddenOuts), hiddenErrors);
        // Adjust weights for hidden layer
        for (let i = 0; i < this.hiddenLayer.length; i++)
            this.backPropagateHiddenNeuron(this.hiddenLayer[i], hiddenErrors[i], this.addBias(inputs));
    }
    backPropagateOutNeuron(neuron, target, prevLayerOuts, prevLayerErrors) {
        let delta = (target - neuron.output) * neuron.output * (1 - neuron.output);
        for (let j = 0; j < neuron.weights.length; j++) {
            prevLayerErrors[j] += delta * neuron.weights[j];
            neuron.weights[j] += this.epsilon * delta * prevLayerOuts[j];
        }
        // delta := (D[j] - Y[j]) * Y[j] * (1 - Y[j]);
        // per ogni unità k del livello H (compreso bias)
        //    ErrH[k] := ErrH[k] + (delta * W2[k,j]);
        //    W2[k,j] := W2[k,j] + (epsilon * delta * H[k]);
    }
    backPropagateHiddenNeuron(neuron, error, inputs) {
        let delta = error * neuron.output * (1 - neuron.output);
        for (let j = 0; j < neuron.weights.length; j++)
            neuron.weights[j] += this.epsilon * delta * inputs[j];
        // delta := ErrH[k] * H[k] * (1 - H[k]);
        // per ogni unità i del livello X (compreso bias)
        //    Wl[i,k] := Wl[i,k] + (epsilon * delta * X[i]);
    }
    // -------------------- Iterative learning --------------------
    learn(examples) {
        let iteration = 0;
        let totalError = 0;
        do {
            for (let i = 0; i < examples.length; i++) {
                let actualOuts = this.forward(examples[i].inputs);
                let expectedOuts = examples[i].outputs;
                this.backPropagate(examples[i].inputs, expectedOuts);
                totalError = this.totalError(actualOuts, expectedOuts);
            }
            iteration++;
            this.reportLearn(iteration, totalError);
        } while (iteration < this.maxLearnIterations && totalError > this.acceptableError);
        return iteration;
        // ripeti (* epoche *)
        // 	 per ogni esempio {X,D}
        // 		esegui la rete con X e trova Y;
        // 		backpropagate;
        // 	 fine;
        // 	 calcola errore dell'intera epoca;
        // finché errore dell'epoca inferiore ad errore ammesso
    }
    reportLearn(iteration, totalError) {
        console.log(`Learn iteration ${iteration} - error: ${totalError}`);
    }
    totalError(actualOuts, expectedOuts) {
        const square = x => x * x;
        let sum = actualOuts.reduce((accum, actualOut, i) => accum + square(actualOut - expectedOuts[i]), 0);
        return sum / 2;
    }
    // -------------------- Misc --------------------
    addBias(values) {
        let biasedValues = values.slice();
        biasedValues.push(1);
        return biasedValues;
    }
}
exports.NeuralNetwork = NeuralNetwork;
// -------------------- Activation functions --------------------
function sigmoid(x) {
    if (x < -45.0)
        return 0.0;
    else if (x > 45.0)
        return 1.0;
    else
        return 1.0 / (1.0 + Math.exp(-x));
}

},{}],2:[function(require,module,exports){
"use strict";
const neurons_1 = require('./neurons');
let nn;
$(function () {
    $('input,textarea').on('input', evt => {
        let formData = getFormData();
        //TODO: validate and activate buttons
    });
    $('#butlearn').click(_ => {
        let formData = getFormData();
        nn = new neurons_1.NeuralNetwork(formData.numInputs, formData.numHidden, formData.numOutputs);
        nn.acceptableError = formData.maxError;
        nn.maxLearnIterations = formData.maxIterations;
        let examples = parseLearnLines(formData.learnLines, formData.numInputs, formData.numOutputs);
        let iterations = nn.learn(examples);
        console.log(`*** Learned in ${iterations} iterations`);
        //TODO: learn
    });
    $('#buttest').click(_ => {
        //TODO: test
    });
});
function getFormData() {
    return {
        numInputs: $('#nimputs').val(),
        numOutputs: $('#noutputs').val(),
        numHidden: $('#nhidden').val(),
        maxError: $('#maxerror').val(),
        maxIterations: $('#maxiters').val(),
        learnLines: $('#ldata').val(),
        testLines: $('#tdata').val()
    };
}
function parseLearnLines(allLines, numInputs, numOutputs) {
    let examples = [];
    let lines = allLines.split('\n');
    lines.forEach((line, i) => {
        if (line.length == 0)
            return;
        let example = parseExample(line);
        //TODO validate line by checking:
        //	- if example is null, then the / is missing
        //	- if the number of inputs or outputs is invalid, then some data is missing
        //	- if some value is NaN, then there are invalid numbers
        if (example)
            examples.push(example);
    });
    return examples;
}
function parseExample(line) {
    let inout = line.split('/');
    if (inout.length < 2)
        return null;
    let inputs = inout[0].split(' ').map(s => parseFloat(s));
    let outputs = inout[1].split(' ').map(s => parseFloat(s));
    return { inputs, outputs };
}

},{"./neurons":1}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvbmV1cm9ucy50cyIsInNyYy9ubm4td2ViLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBLE1BQU0sMkJBQTJCLEdBQUcsT0FBTyxDQUFDO0FBVzVDO0lBSUMsWUFBWSxVQUFrQjtRQUM3QixJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztRQUNsQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNsQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsRUFBRSxDQUFDLEVBQUU7WUFDbEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDbkMsQ0FBQztBQUNGLENBQUM7QUFWWSxjQUFNLFNBVWxCLENBQUE7QUFHRDtJQVNDLFlBQW9CLFNBQWlCLEVBQVUsU0FBaUIsRUFBVSxVQUFrQjtRQUF4RSxjQUFTLEdBQVQsU0FBUyxDQUFRO1FBQVUsY0FBUyxHQUFULFNBQVMsQ0FBUTtRQUFVLGVBQVUsR0FBVixVQUFVLENBQVE7UUFDM0YsNEJBQTRCO1FBQzVCLElBQUksQ0FBQyxjQUFjLEdBQUcsMkJBQTJCLENBQUM7UUFDbEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7UUFDN0IsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztRQUMvQixvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFDdEIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLElBQUks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QUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekQsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFELE1BQU0sQ0FBQyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQztBQUM1QixDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImNvbnN0IERFRkFVTFRfQUNUSVZBVElPTl9GVU5DVElPTiA9IHNpZ21vaWQ7XG5cbnR5cGUgQWN0aXZhdGlvbkZ1bmN0aW9uID0gKG51bWJlcikgPT4gbnVtYmVyO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhhbXBsZSB7XG5cdGlucHV0czogbnVtYmVyW107XG5cdG91dHB1dHM6IG51bWJlcltdO1xufVxuXG5cbmV4cG9ydCBjbGFzcyBOZXVyb24ge1xuXHR3ZWlnaHRzOiBudW1iZXJbXTtcblx0b3V0cHV0OiBudW1iZXI7XG5cblx0Y29uc3RydWN0b3IobnVtV2VpZ2h0czogbnVtYmVyKSB7XG5cdFx0dGhpcy5vdXRwdXQgPSBOYU47XG5cdFx0dGhpcy53ZWlnaHRzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1XZWlnaHRzOyBpKyspXG5cdFx0XHR0aGlzLndlaWdodHMucHVzaChNYXRoLnJhbmRvbSgpKTtcblx0fVxufVxuXG5cbmV4cG9ydCBjbGFzcyBOZXVyYWxOZXR3b3JrIHtcblx0aGlkZGVuTGF5ZXI6IE5ldXJvbltdO1xuXHRvdXRwdXRMYXllcjogTmV1cm9uW107XG5cdC8vIFR1bmFibGUgcGFyYW1ldGVyc1xuXHRhY3RpdmF0aW9uRnVuYzogQWN0aXZhdGlvbkZ1bmN0aW9uO1xuXHRlcHNpbG9uOiBudW1iZXI7XG5cdGFjY2VwdGFibGVFcnJvcjogbnVtYmVyO1xuXHRtYXhMZWFybkl0ZXJhdGlvbnM6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIG51bUlucHV0czogbnVtYmVyLCBwcml2YXRlIG51bUhpZGRlbjogbnVtYmVyLCBwcml2YXRlIG51bU91dHB1dHM6IG51bWJlcikge1xuXHRcdC8vIEluaXRpYWxpemUgZGVmYXVsdCBwYXJhbXNcblx0XHR0aGlzLmFjdGl2YXRpb25GdW5jID0gREVGQVVMVF9BQ1RJVkFUSU9OX0ZVTkNUSU9OO1xuXHRcdHRoaXMuZXBzaWxvbiA9IDAuNTtcblx0XHR0aGlzLmFjY2VwdGFibGVFcnJvciA9IDAuMDAxO1xuXHRcdHRoaXMubWF4TGVhcm5JdGVyYXRpb25zID0gMTAwMDtcblx0XHQvLyBJbml0aWFsaXplIGxheWVyc1xuXHRcdHRoaXMuaGlkZGVuTGF5ZXIgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG51bUhpZGRlbjsgaSsrKVxuXHRcdFx0dGhpcy5oaWRkZW5MYXllci5wdXNoKG5ldyBOZXVyb24odGhpcy5udW1JbnB1dHMgKyAxKSk7XG5cdFx0dGhpcy5vdXRwdXRMYXllciA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT3V0cHV0czsgaSsrKVxuXHRcdFx0dGhpcy5vdXRwdXRMYXllci5wdXNoKG5ldyBOZXVyb24odGhpcy5udW1IaWRkZW4gKyAxKSk7XG5cdH1cblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBGb3J3YXJkIHByb3BhZ2F0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0Zm9yd2FyZE5ldXJvbihuZXVyb246IE5ldXJvbiwgaW5wdXRzOiBudW1iZXJbXSk6IG51bWJlciB7XG5cdFx0aWYgKGlucHV0cy5sZW5ndGggIT0gbmV1cm9uLndlaWdodHMubGVuZ3RoKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemUgb2YgaW5wdXQgYXJyYXk6IGV4cGVjdGluZyAke25ldXJvbi53ZWlnaHRzLmxlbmd0aH0sIGdvdCAke2lucHV0cy5sZW5ndGh9YCk7XG5cdFx0bGV0IHdlaWdodGVkU3VtID0gaW5wdXRzLnJlZHVjZShcblx0XHRcdChhY2N1bSwgaW5wdXQsIGkpID0+IGFjY3VtICsgaW5wdXQgKiBuZXVyb24ud2VpZ2h0c1tpXSwgMCk7XG5cdFx0bmV1cm9uLm91dHB1dCA9IHRoaXMuYWN0aXZhdGlvbkZ1bmMod2VpZ2h0ZWRTdW0pO1xuXHRcdHJldHVybiBuZXVyb24ub3V0cHV0O1xuXHR9XG5cblx0Zm9yd2FyZChpbnB1dHM6IG51bWJlcltdKTogbnVtYmVyW10ge1xuXHRcdGxldCBobFZhbHVlczogbnVtYmVyW10gPSBbXTtcblx0XHRsZXQgb3V0VmFsdWVzOiBudW1iZXJbXSA9IFtdO1xuXHRcdHRoaXMuaGlkZGVuTGF5ZXIuZm9yRWFjaChuZXVyb24gPT5cblx0XHRcdGhsVmFsdWVzLnB1c2godGhpcy5mb3J3YXJkTmV1cm9uKG5ldXJvbiwgdGhpcy5hZGRCaWFzKGlucHV0cykpKVxuXHRcdCk7XG5cdFx0aGxWYWx1ZXMucHVzaCgxKTtcdFx0Ly8gQWRkIGJpYXNcblx0XHR0aGlzLm91dHB1dExheWVyLmZvckVhY2gobmV1cm9uID0+XG5cdFx0XHRvdXRWYWx1ZXMucHVzaCh0aGlzLmZvcndhcmROZXVyb24obmV1cm9uLCBobFZhbHVlcykpXG5cdFx0KTtcblx0XHRyZXR1cm4gb3V0VmFsdWVzO1xuXHR9XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gQmFjayBwcm9wYWdhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdGJhY2tQcm9wYWdhdGUoaW5wdXRzOiBudW1iZXJbXSwgdGFyZ2V0czogbnVtYmVyW10pOiB2b2lkIHtcblx0XHQvLyBBZGp1c3Qgd2VpZ2h0cyBmb3Igb3V0cHV0IGxheWVyXG5cdFx0bGV0IGhpZGRlbk91dHMgPSB0aGlzLmhpZGRlbkxheWVyLm1hcChuZXVyb24gPT4gbmV1cm9uLm91dHB1dCk7XG5cdFx0bGV0IGhpZGRlbkVycm9yczogbnVtYmVyW10gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGlkZGVuTGF5ZXIubGVuZ3RoOyBpKyspIGhpZGRlbkVycm9ycy5wdXNoKDApO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRMYXllci5sZW5ndGg7IGkrKylcblx0XHRcdHRoaXMuYmFja1Byb3BhZ2F0ZU91dE5ldXJvbihcblx0XHRcdFx0dGhpcy5vdXRwdXRMYXllcltpXSwgdGFyZ2V0c1tpXSwgdGhpcy5hZGRCaWFzKGhpZGRlbk91dHMpLCBoaWRkZW5FcnJvcnMpO1xuXHRcdC8vIEFkanVzdCB3ZWlnaHRzIGZvciBoaWRkZW4gbGF5ZXJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGlkZGVuTGF5ZXIubGVuZ3RoOyBpKyspXG5cdFx0XHR0aGlzLmJhY2tQcm9wYWdhdGVIaWRkZW5OZXVyb24oXG5cdFx0XHRcdHRoaXMuaGlkZGVuTGF5ZXJbaV0sIGhpZGRlbkVycm9yc1tpXSwgdGhpcy5hZGRCaWFzKGlucHV0cykpO1xuXHR9XG5cblx0YmFja1Byb3BhZ2F0ZU91dE5ldXJvbihuZXVyb246IE5ldXJvbiwgdGFyZ2V0OiBudW1iZXIsXG5cdFx0cHJldkxheWVyT3V0czogbnVtYmVyW10sIHByZXZMYXllckVycm9yczogbnVtYmVyW10pOiB2b2lkIHtcblx0XHRsZXQgZGVsdGEgPSAodGFyZ2V0IC0gbmV1cm9uLm91dHB1dCkgKiBuZXVyb24ub3V0cHV0ICogKDEgLSBuZXVyb24ub3V0cHV0KTtcblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG5ldXJvbi53ZWlnaHRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRwcmV2TGF5ZXJFcnJvcnNbal0gKz0gZGVsdGEgKiBuZXVyb24ud2VpZ2h0c1tqXTtcblx0XHRcdG5ldXJvbi53ZWlnaHRzW2pdICs9IHRoaXMuZXBzaWxvbiAqIGRlbHRhICogcHJldkxheWVyT3V0c1tqXTtcblx0XHR9XG5cdFx0Ly8gZGVsdGEgOj0gKERbal0gLSBZW2pdKSAqIFlbal0gKiAoMSAtIFlbal0pO1xuXHRcdC8vIHBlciBvZ25pIHVuaXTDoCBrIGRlbCBsaXZlbGxvIEggKGNvbXByZXNvIGJpYXMpXG5cdFx0Ly8gICAgRXJySFtrXSA6PSBFcnJIW2tdICsgKGRlbHRhICogVzJbayxqXSk7XG5cdFx0Ly8gICAgVzJbayxqXSA6PSBXMltrLGpdICsgKGVwc2lsb24gKiBkZWx0YSAqIEhba10pO1xuXHR9XG5cblx0YmFja1Byb3BhZ2F0ZUhpZGRlbk5ldXJvbihuZXVyb246IE5ldXJvbiwgZXJyb3I6IG51bWJlciwgaW5wdXRzOiBudW1iZXJbXSk6IHZvaWQge1xuXHRcdGxldCBkZWx0YSA9IGVycm9yICogbmV1cm9uLm91dHB1dCAqICgxIC0gbmV1cm9uLm91dHB1dCk7XG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBuZXVyb24ud2VpZ2h0cy5sZW5ndGg7IGorKylcblx0XHRcdG5ldXJvbi53ZWlnaHRzW2pdICs9IHRoaXMuZXBzaWxvbiAqIGRlbHRhICogaW5wdXRzW2pdO1xuXHRcdC8vIGRlbHRhIDo9IEVyckhba10gKiBIW2tdICogKDEgLSBIW2tdKTtcblx0XHQvLyBwZXIgb2duaSB1bml0w6AgaSBkZWwgbGl2ZWxsbyBYIChjb21wcmVzbyBiaWFzKVxuXHRcdC8vICAgIFdsW2ksa10gOj0gV2xbaSxrXSArIChlcHNpbG9uICogZGVsdGEgKiBYW2ldKTtcblx0fVxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIEl0ZXJhdGl2ZSBsZWFybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdGxlYXJuKGV4YW1wbGVzOiBFeGFtcGxlW10pOiBudW1iZXIge1xuXHRcdGxldCBpdGVyYXRpb24gPSAwO1xuXHRcdGxldCB0b3RhbEVycm9yID0gMDtcblx0XHRkbyB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxldCBhY3R1YWxPdXRzID0gdGhpcy5mb3J3YXJkKGV4YW1wbGVzW2ldLmlucHV0cyk7XG5cdFx0XHRcdGxldCBleHBlY3RlZE91dHMgPSBleGFtcGxlc1tpXS5vdXRwdXRzO1xuXHRcdFx0XHR0aGlzLmJhY2tQcm9wYWdhdGUoZXhhbXBsZXNbaV0uaW5wdXRzLCBleHBlY3RlZE91dHMpO1xuXHRcdFx0XHR0b3RhbEVycm9yID0gdGhpcy50b3RhbEVycm9yKGFjdHVhbE91dHMsIGV4cGVjdGVkT3V0cyk7XG5cdFx0XHR9XG5cdFx0XHRpdGVyYXRpb24rKztcblx0XHRcdHRoaXMucmVwb3J0TGVhcm4oaXRlcmF0aW9uLCB0b3RhbEVycm9yKTtcblx0XHR9IHdoaWxlIChpdGVyYXRpb24gPCB0aGlzLm1heExlYXJuSXRlcmF0aW9ucyAmJiB0b3RhbEVycm9yID4gdGhpcy5hY2NlcHRhYmxlRXJyb3IpO1xuXHRcdHJldHVybiBpdGVyYXRpb247XG5cdFx0Ly8gcmlwZXRpICgqIGVwb2NoZSAqKVxuXHRcdC8vIFx0IHBlciBvZ25pIGVzZW1waW8ge1gsRH1cblx0XHQvLyBcdFx0ZXNlZ3VpIGxhIHJldGUgY29uIFggZSB0cm92YSBZO1xuXHRcdC8vIFx0XHRiYWNrcHJvcGFnYXRlO1xuXHRcdC8vIFx0IGZpbmU7XG5cdFx0Ly8gXHQgY2FsY29sYSBlcnJvcmUgZGVsbCdpbnRlcmEgZXBvY2E7XG5cdFx0Ly8gZmluY2jDqSBlcnJvcmUgZGVsbCdlcG9jYSBpbmZlcmlvcmUgYWQgZXJyb3JlIGFtbWVzc29cblx0fVxuXG5cdHJlcG9ydExlYXJuKGl0ZXJhdGlvbiwgdG90YWxFcnJvcikge1xuXHRcdGNvbnNvbGUubG9nKGBMZWFybiBpdGVyYXRpb24gJHtpdGVyYXRpb259IC0gZXJyb3I6ICR7dG90YWxFcnJvcn1gKTtcblx0fVxuXG5cdHRvdGFsRXJyb3IoYWN0dWFsT3V0czogbnVtYmVyW10sIGV4cGVjdGVkT3V0czogbnVtYmVyW10pOiBudW1iZXIge1xuXHRcdGNvbnN0IHNxdWFyZSA9IHggPT4geCAqIHg7XG5cdFx0bGV0IHN1bSA9IGFjdHVhbE91dHMucmVkdWNlKFxuXHRcdFx0KGFjY3VtLCBhY3R1YWxPdXQsIGkpID0+IGFjY3VtICsgc3F1YXJlKGFjdHVhbE91dCAtIGV4cGVjdGVkT3V0c1tpXSksIDApO1xuXHRcdHJldHVybiBzdW0gLyAyO1xuXHR9XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gTWlzYyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdGFkZEJpYXModmFsdWVzOiBudW1iZXJbXSk6IG51bWJlcltdIHtcblx0XHRsZXQgYmlhc2VkVmFsdWVzID0gdmFsdWVzLnNsaWNlKCk7XG5cdFx0Ymlhc2VkVmFsdWVzLnB1c2goMSk7XG5cdFx0cmV0dXJuIGJpYXNlZFZhbHVlcztcblx0fVxufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIEFjdGl2YXRpb24gZnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHNpZ21vaWQoeDogbnVtYmVyKTogbnVtYmVyIHtcblx0aWYgKHggPCAtNDUuMCkgcmV0dXJuIDAuMDtcblx0ZWxzZSBpZiAoeCA+IDQ1LjApIHJldHVybiAxLjA7XG5cdGVsc2UgcmV0dXJuIDEuMCAvICgxLjAgKyBNYXRoLmV4cCgteCkpO1xufVxuIiwiaW1wb3J0IHsgTmV1cmFsTmV0d29yaywgRXhhbXBsZSB9IGZyb20gJy4vbmV1cm9ucyc7XG5cbmxldCBubjogTmV1cmFsTmV0d29yaztcblxuJChmdW5jdGlvbigpIHtcblx0JCgnaW5wdXQsdGV4dGFyZWEnKS5vbignaW5wdXQnLCBldnQgPT4ge1xuXHRcdGxldCBmb3JtRGF0YSA9IGdldEZvcm1EYXRhKCk7XG5cdFx0Ly9UT0RPOiB2YWxpZGF0ZSBhbmQgYWN0aXZhdGUgYnV0dG9uc1xuXHR9KTtcblx0JCgnI2J1dGxlYXJuJykuY2xpY2soXyA9PiB7XG5cdFx0bGV0IGZvcm1EYXRhID0gZ2V0Rm9ybURhdGEoKTtcblx0XHRubiA9IG5ldyBOZXVyYWxOZXR3b3JrKGZvcm1EYXRhLm51bUlucHV0cywgZm9ybURhdGEubnVtSGlkZGVuLCBmb3JtRGF0YS5udW1PdXRwdXRzKTtcblx0XHRubi5hY2NlcHRhYmxlRXJyb3IgPSBmb3JtRGF0YS5tYXhFcnJvcjtcblx0XHRubi5tYXhMZWFybkl0ZXJhdGlvbnMgPSBmb3JtRGF0YS5tYXhJdGVyYXRpb25zO1xuXHRcdGxldCBleGFtcGxlcyA9IHBhcnNlTGVhcm5MaW5lcyhmb3JtRGF0YS5sZWFybkxpbmVzLCBmb3JtRGF0YS5udW1JbnB1dHMsIGZvcm1EYXRhLm51bU91dHB1dHMpO1xuXHRcdGxldCBpdGVyYXRpb25zID0gbm4ubGVhcm4oZXhhbXBsZXMpO1xuXHRcdGNvbnNvbGUubG9nKGAqKiogTGVhcm5lZCBpbiAke2l0ZXJhdGlvbnN9IGl0ZXJhdGlvbnNgKTtcblx0XHQvL1RPRE86IGxlYXJuXG5cdH0pO1xuXHQkKCcjYnV0dGVzdCcpLmNsaWNrKF8gPT4ge1xuXHRcdC8vVE9ETzogdGVzdFxuXHR9KTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRGb3JtRGF0YSgpIHtcblx0cmV0dXJuIHtcblx0XHRudW1JbnB1dHM6ICQoJyNuaW1wdXRzJykudmFsKCksXG5cdFx0bnVtT3V0cHV0czogJCgnI25vdXRwdXRzJykudmFsKCksXG5cdFx0bnVtSGlkZGVuOiAkKCcjbmhpZGRlbicpLnZhbCgpLFxuXHRcdG1heEVycm9yOiAkKCcjbWF4ZXJyb3InKS52YWwoKSxcblx0XHRtYXhJdGVyYXRpb25zOiAkKCcjbWF4aXRlcnMnKS52YWwoKSxcblx0XHRsZWFybkxpbmVzOiAkKCcjbGRhdGEnKS52YWwoKSxcblx0XHR0ZXN0TGluZXM6ICQoJyN0ZGF0YScpLnZhbCgpXG5cdH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGVhcm5MaW5lcyhhbGxMaW5lczogc3RyaW5nLCBudW1JbnB1dHM6IG51bWJlciwgbnVtT3V0cHV0czogbnVtYmVyKTogRXhhbXBsZVtdIHtcblx0bGV0IGV4YW1wbGVzOiBFeGFtcGxlW10gPSBbXTtcblx0bGV0IGxpbmVzID0gYWxsTGluZXMuc3BsaXQoJ1xcbicpO1xuXHRsaW5lcy5mb3JFYWNoKChsaW5lLCBpKSA9PiB7XG5cdFx0aWYgKGxpbmUubGVuZ3RoID09IDApIHJldHVybjtcblx0XHRsZXQgZXhhbXBsZSA9IHBhcnNlRXhhbXBsZShsaW5lKTtcblx0XHQvL1RPRE8gdmFsaWRhdGUgbGluZSBieSBjaGVja2luZzpcblx0XHQvL1x0LSBpZiBleGFtcGxlIGlzIG51bGwsIHRoZW4gdGhlIC8gaXMgbWlzc2luZ1xuXHRcdC8vXHQtIGlmIHRoZSBudW1iZXIgb2YgaW5wdXRzIG9yIG91dHB1dHMgaXMgaW52YWxpZCwgdGhlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xuXHRcdC8vXHQtIGlmIHNvbWUgdmFsdWUgaXMgTmFOLCB0aGVuIHRoZXJlIGFyZSBpbnZhbGlkIG51bWJlcnNcblx0XHRpZiAoZXhhbXBsZSkgZXhhbXBsZXMucHVzaChleGFtcGxlKTtcblx0fSk7XG5cdHJldHVybiBleGFtcGxlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VFeGFtcGxlKGxpbmU6IHN0cmluZyk6IEV4YW1wbGUgfCBudWxsIHtcblx0bGV0IGlub3V0ID0gbGluZS5zcGxpdCgnLycpO1xuXHRpZiAoaW5vdXQubGVuZ3RoIDwgMikgcmV0dXJuIG51bGw7XG5cdGxldCBpbnB1dHMgPSBpbm91dFswXS5zcGxpdCgnICcpLm1hcChzID0+IHBhcnNlRmxvYXQocykpO1xuXHRsZXQgb3V0cHV0cyA9IGlub3V0WzFdLnNwbGl0KCcgJykubWFwKHMgPT4gcGFyc2VGbG9hdChzKSk7XG5cdHJldHVybiB7IGlucHV0cywgb3V0cHV0cyB9O1xufVxuIl19
